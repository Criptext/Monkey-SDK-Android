# Getting Started

MonkeyKit on Android supports 4.1 (API 16) and above.

## Using Gradle + Maven

In your app's build.gradle file add the following block to your repositories block:
```
repositories { 
    maven {
        url 'https://dl.bintray.com/criptext/maven'
    } 
}
```

Then add the following to your app's build.gradle file dependencies block:
```
dependencies {
    compile ('com.criptext:MonkeyKit:1.1.0@aar') {
        transitive = true;
    }
}
```

## Extending MonkeyKit service

To use MonkeyKit service, you need to extend `MonkeyKit.java` in your application and implement all of its abstract methods. You must create a database that MonkeyKit can access to store messages that are received while your activites are closed. The following methods must be implemented:

- `public abstract void storeMessage(MOKMessage message);`
  
This method stores a message received by MonkeyKit into your database. You should store them in a way that is convenient for your application to access, since MonkeyKit does not query this messages, only stores them. This is specially useful for messages that are received while your activites are closed. The implementation should be asynchronous to maximize your apps performance. Once you have successfully stored your message, you must call `notifyMessageStored()` so that it is forwarded to your delegates.

- `public abstract void storeMessageBatch(ArrayList<MOKMessage> messages);`
  
This method stores a group of messages received by MonkeyKit into your database. Whenever MonkeyKit reconnects, it catches up with the server and receives all the messages that should have been received during the down time. You should store them in a way that is convenient for your application to access, since MonkeyKit does not query this messages, only stores them. Since this method could receive a list of potentially hundreds of messages, the implementation should be asynchronous. Once you have successfully stored your batch, you must call `notifyBatchStored()` so that it is forwarded to your delegates.

### How to persist MOKMessages

The `MOKMessage` class has lots of attributes. You don't need to persist them
all, since a lot of them are only used internally by `MonkeyKit`. the attributes
that you should persist are:
- `message_id` A string with an unique ID that MonkeyKit sets to each message.
  You should index your messages using this ID. This ID is a timestamp, and it
  is a negative number while it is being transmitted to the server. After that,
  it becomes a positive number. 
- `sid` A string with the session ID of the user who sent the message. 
- `rid` A string with the session ID of the user who is meant to receive the
  message. This attribute may also contain a group ID instead of a session ID
  when the message was sent to a group conversation. 
- `datetime` A string with the timestamp of the date in which the message was
  sent. This timestamp should be used to display the dates of messages.
- `datetimeorder` A long with the timestamp of the date in which the message
  was received. This timestamp should only be used to order messages because
  it's the only timestamp guaranteed to be generated by the same clock: the one
  in the receiver's device.
- `msg` A string with the text message sent by the user. If the user sent a file
  instead of a plain text message, it contains the file's name.
- `params` A `JsonObject` with additional parameters that your application may
  find useful. You are free to manipulate this object as you wish. MonkeyKit
  will send the exact same `params` object to the receiver.
- `props` A `JsonObject` with additional parameters that MonkeyKit may find 
  useful. You must not modify this object, use `params` instead for your
  applications logic. You will need to give this object back to MonkeyKit when
  you wish to download a file sent by another user, so make sure that no data is
  lost after persisting it.  
- `type` A string containing the message's file type. You should compare this
  value with the constants defined in `MessageTypes.FileTypes` to find out the
  message's type. 

Here is an example of a MonkeyKit implementation using
[Realm](https://realm.io/):

```
public class MonkeyKitRealm extends MonkeyKit{
    private Realm msgRealm;

    public RealmConfiguration getMessagesConfig(){
        RealmConfiguration config = new RealmConfiguration.Builder(this.getApplicationContext())
                                .name("MessagesDB")
                                .build();
        return config;
    }
				
    public Realm getNewMsgRealmInstance(){
            RealmConfiguration config = getMessagesConfig();
            return Realm.getInstance(config);
    }

    public Realm getMsgRealm(){
        if(msgRealm == null) {
            msgRealm =  getNewMsgRealmInstance();
        }
        return msgRealm;
    }

    private void insertOneMessage(final MOKMessage mess){
        MOKModel model =
        realm.where(MOKModel.class).equalTo("message_id",
                mess.getMessage_id()).findFirst();
        if(model != null){
            model = realm.createObject(MOKModel.class);
            model.setMessage_id(mess.getMessage_id());
            model.setDatetime(mess.getDatetime());
            model.setDatetimeorder(mess.getDatetimeorder());
            model.setMsg(mess.getMsg());
            model.setSid(mess.getSid());
            model.setRid(mess.getRid());
            model.setType(mess.getType());
            model.setProps(mess.getProps().toString());
            if(model.getParams() != null)
                model.setParams(mess.getParams());
        }
    }


    @Override
    public void storeMessage(MOKMessage message) {
        final MOKMessage mess = message;
        Realm realm = getMsgRealm();
        realm.executeTransaction(realm, new Realm.Transaction() {
            @Override
            public void execute(Realm realm){
                insertOneMessage(mess);
            }
        }, new Realm.Transaction.Callback() {
                    @Override
                    public void onSuccess() {
                        Log.d("addMessage", "SUCCESS");
                        messageStored(mess);
                    }

                    @Override
                    public void onError(Exception e) {
                        e.printStackTrace();
                        // transaction is automatically rolled-back, do any cleanup here
                    }
        });

    }

    @Override
    public void storeMessageBatch(ArrayList<MOKMessage> messages) {
        final ArrayList<MOKMessage> batch = messages;
        Realm realm = getMsgRealm();
        realm.executeTransaction(realm, new Realm.Transaction() {
            @Override
            public void execute(Realm realm){
                for(int i = 0; i < messages.size(); i++)
                    insertOneMessage(messages.get(i);
            }, new Realm.Transaction.Callback(){
            @Override
                public void onError(Exception e) {
                    e.printStackTrace();
                }

                @Override
                public void onSuccess() {
                    batchStored(batch);
                }
            }
        });

    }

}
```

## Register user with MonkeyKit

In order to send and receive messages a user must first register and get a session id. This process should be done only once: the first time the user opens your app. To do this, first, you must create a new `MonkeyInit` object

```
MonkeyInit init = new MonkeyInit(MyActivity.this, null, MY_APP_ID, MY_APP_KEY){
    @Override
    public void onSessionOK(String sessionID){
        persistSession(sessionID);
    }
}.register();
```

The constructor recieves 4 arguments: 
- A context reference 
- A string with a previous session ID
- A string with the app's ID
- A string with the app's secret key

If you have determined that the user already has a previous session and would like to keep using it, don't use it immediately. First register with that session ID as the second argument so that MonkeyKit can verify that it is a valid ID and can still be used. For new users you can use `null` or an empty string as the second argument.

As for the last two arguments, You should have received an app ID and secret key from Criptext. 

Finally override the `onSessionOK` method which is a callback containing a single argument: A valid session ID. The register process consists of various HTTP requests so it is executed asynchronously. After it's all done, the callback with your new session ID is executed. Once you have persisted it, you can start your MonkeyKit service and comence sending and receiving messages.

After you have yout `MonkeyInit` object ready, you can start the register
process by calling the `register()` method.

## Starting the service

Once you have your session ID ready, you can start the MonkeyKit service using the static method `startMonkeyService`. The arguments for this method are: 
- A context reference
- The class that extends MonkeyKit implementing all the abstract methods 
- A string with the user's full name
- A string with the app's ID
- A string with the app's secret key
```
MonkeyKit.startMonkeyService(MyActivity.this, MyMonkeyService.class,
				user.getFullName(),
				user.getSessionID(),
				MY_APP_ID, MY_APP_KEY);

```
After starting the service MonkeyKit will connect to the server and immediately start receiving messages.

## Adding a delegate

MonkeyKit needs a delegate to tell your application about the messages and notifications that it has received. Any object that you wish to use as delegate should implement the `MonkeyKitDelegate` interface. This interface has lots of methods, but they all basically callbacks that return `void`. You can use an `Activity` as a delegate like this:

```
public class MyActivity extends Activity implements MonkeyKitDelegate {
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.my_activity);
        MonkeyKit.instance().addDelegate(this);
    }

    @Override
    public void onMessageReceived(MOKMessage message){
        Toast.makeText(this, "Received " + message.getMsg(), Toast.LENGTH_SHORT).show();
    }
```

You can read more about delegates
[here.](https://github.com/Criptext/MonkeyKitAndroid/wiki/MonkeyKitDelegate-Callbacks)

## Sending messages

With MonkeyKit, you can easily send messages to other users. All you need is the
receiver's session ID. Both parties do not need to be online at the same time,
as MonkeyKit will resend the message if needed. You can easily 
send a text message using the `sendMessage()` method. Its 4 parameters are:
- A string with the text message
- A string with the session ID of the user who will receive the message
- A string with the message to show in the push notification
- A `JsonObject` with additional parameters to send. The receiver will get the
  exact same `JsonObject` in the `params` attribute of the `MOKMessage` class.
  This allows you to send customized messages.

The method immediately returns the message as a `MOKMessage` object as it
asynchronously sends it into the network. This `MOKMessage` object is 
important because it contains the message ID and the timestamp that MonkeyKit 
has given to your message. If you want MonkeyKit to store the message into the
database using the `storeMessage()` method that you implemented before sending
the message, you can use the `persistMessageAndSend()` method instead. 

You can send a "Hello World" message like this:

```
MyMessage newMessage = new MyMessage("Hello World!");
JsonObject params = createJsonWithAdditionalParams();
MOKMessage sentMessage = MonkeyKit.instance().sendMessage(newMessage.getText(),
friend.getSessionID(), "You have received a message via MonkeyKit!", params);
newMessage.setID(sentMessage.getMessage_id());
```

To handle the sent text message, the receiver should implement the
`onMessageReceived()` method of `MonkeyKitDelegate` like this:

```
@Override
    public void onMessageReceived(MOKMessage message){
        String friend = getFriendBySessionID(message.getSid());
        String text = friend.getName() + " says: " message.getMsg();
        Toast.makeText(this, text, Toast.LENGTH_SHORT).show();
    }
```



### Sending files

If you want to send a photo or a voice note you should use the
`sendFileMessage()` method. Its 5 parameters are: 
- A string with the absolute path to the file to upload
- A string with the session ID of the user who will receive the message
- A string with the file type. You should use `MessageTypes.FileTypes.Audio` for
  audio messages and `MessageTypes.FileTypes.Photo` for Images
- A `JsonObject` with additional parameters to send. The receiver will get the
  exact same `JsonObject in the `params` attribute of the `MOKMessage` class.
  This allows you to send customized messages.
- A string with the message to show in the push notification

The method immediately returns the message as a `MOKMessage` object as it
asynchronously sends it into the network. this `MOKMessage` object is important 
because it contains the message ID and the timestamp that MonkeyKit has given to
your message.If you want MonkeyKit to store the message into the database using
the `storeMessage()` method that you implemented before sending the message, you
can use the `persistFileMessageAndSend()` method instead. 

Here's an example for a voice note message:

```
//send voice note's duration in params
JsonObject params = new JsonObject();
params.addProperty("duration", voiceNote.getDuration()); 
MOKMessage sentMessage =
MonkeyKit.instance().sendFileMessage(voiceNote.getAbsolutePath(), 
friend.getSessionID(), "You have received a voice note via MonkeyKit!", params);
```
To handle the sent file message, the receiver should implement the
`onMessageReceived()` method of `MonkeyKitDelegate` like this:

```
@Override
    public void onMessageReceived(MOKMessage message){
        switch(message.getType()){
            case MessageTypes.FileTypes.Default:
                //handle text message
                break;
            case MessageTypes.FileTypes.Audio:
                //handle audio message
                break;
            case MessageTypes.FileTypes.Photo:
                //handle image message
                break;
        }
    }
```

Using the `getType()` method you can easily distinguish between voice notes and
photos. Please note that MOKMessages can only contain your file's metadata. To
view the file, you must first download it via HTTP using MonkeyKit's
`downloadFile()` method. It has 4 parameters:
- A string with the path in which the file will be saved after downloading.
- the `props` attribute from `MOKMessage`. It is a `JsonObject`.
- A string with the session ID from the user who sent the file.
- A runnable with any code that you want to execute once the download finishes.

Here's an implementation of `onMessageReceived` that plays an audio file after
download:

```
@Override
    public void onMessageReceived(MOKMessage message){
        switch(message.getType()){
            case MessageTypes.FileTypes.Default:
                //handle text message
                break;
            case MessageTypes.FileTypes.Audio:
                final String senderID = message.getSid();
                final String filePath = this.getCacheDir().getAbsolutePath()
                +"/"+ message.getMsg(); //getMsg() has the filename
                Runnable runnable = new Runnable(){
                    @Override
                    public void run(){
                        //Play Audio
                        MediaPlayer mPlayer = new MediaPlayer();
			mPlayer.setDataSource(filepath);
			mPlayer.setAudioStreamType(AudioManager.STREAM_VOICE_CALL);
			mPlayer.prepare();
			mPlayer.start(); 
                    }
                });
                MonkeyKit.instance().downloadFile(filepath, senderID,
                message.getProps(), runnable);
                break;
            case MessageTypes.FileTypes.Photo:
                //handle image message
                break;
        }
    }
```

To view the actual file, you must first download it using the `downloadFile()`
method. Its 4 parameters are:

- A string with the absolute path where the file will be saved to.
- A Json object with the `props` attribute of the `MOKMessage` received.
- A string with the session ID of the user who sent the file.
- A `Runnable` with code to execute once the download finishes.

For example you could download a photo and show it to the user using the AQuery
library like this:
```

final String path = getCacheDir().getAbsolutePath();
JsonObject props = parser.parse(message.getProps()).getAsJsonObject();
String session = friend.getSessionId();

MonkeyKit.instance().downloadFile(path, props, session, new Runnable(){
    public void run(){
        AQuery aq = new AQuery(MainActivity.this);
        aq.id(R.id.image_in_view).image(path + '/' + message.getMessage(), 200);

    }
});

```

## Sending notifications

Notifications are messages that are not persisted in the database. Once the
notification is received, it is processed but never stored in the database. You
should use notifications when you want to send custom data that aren't files or
text messages. To send a temporal notification, use the `sendNotification()` 
method which has the following 3 parameters:
- A string with the session ID of the user who will receive the notifications
- A `JsonObject` with the data  to send. The receiver will get the
  exact same `JsonObject` in the `params` attribute of the `MOKMessage` class.
- A string with the message to show in the push notification

Here's an example of a notification that informs other users that you changed
your avatar:

```
JsonObject params = new JsonObject();
params.addProperty("profileUpdate", "avatar"); 
String text = user.getName() + " updated his avatar");
MonkeyKit.instance().sendTemporalNotification(friend.getSessionID(), params,
text);
```

Notifications are received as `MOKMessage` objects in the 
`onNotificationReceived()` callback of `MonkeyKitDelegate`.The receiver can 
handle the notification like this:

```
@Override
    public void onNotificationReceived(MOKMessage message) {
        String friend = getFriendBySessionID(message.getSid());
        String text = null;
        if(message.getParams().get("profileUpdate") != null && 
            message.getParams().get("profileUpdate").getAsString.equals("avatar"))
            updateAvatar(message.getSid());
    }
```

## Sending temporal notifications

Sometimes you want to send data in real time to other users, but this data is only
useful if both parties are online. For example you might to notify other users
that you just got online, or you want to tell them that you are currently typing
a new message. It's better to not receive these things than to receive them 
late, because by then the data might be out of date. MonkeyKit's temporal 
notifications are exactly this, they are not resent. To send a temporal 
notification, use the `sendTemporalNotification()` method which has the 
following 2 parameters:
- A string with the session ID of the user who will receive the notifications
- A `JsonObject` with the data  to send. The receiver will get the
  exact same `JsonObject` in the `params` attribute of the `MOKMessage` class.

Here's an example of a temporal notification that informs other users that you 
are currently online:

```
JsonObject params = new JsonObject();
//online = 1; offline = 0
params.addProperty("online", 0); 
MonkeyKit.instance().sendTemporalNotification(friend.getSessionID(), params);
```

Notifications are received as `MOKMessage` objects in the
`onNotificationReceived()` callback of `MonkeyKitDelegate`. You can handle
the previously sent notification like this:

```
@Override
    public void onNotificationReceived(MOKMessage message) {
        String friend = getFriendBySessionID(message.getSid());
        String text = null;
        if(message.getParams().get("online") != null && 
            message.getParams().get("online").getAsInt() == 1)
            text = " is online";
        else
            text = " is offline";
        Toast.makeText(this, friend + text, Toast.LENGTH_SHORT).show();
    }
```
